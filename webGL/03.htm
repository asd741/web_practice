<<<<<<< HEAD
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    body {
        margin: 0px;
    }

    #stats {
        position: absolute;
        left: 0;
        top: 0;
    }
</style>

<body>
    <div id="stats"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/96/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

    <script>
        let renderer, scene, camera;
        let cameraControl, stats;

        function initStats() {
            const stats = new Stats();
            stats.setMode(0);
            document.getElementById('stats').appendChild(stats.domElement);
            return stats;
        }

        // 自訂頂點創建粒子系統

        function generateSprite(color) {
            var canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;

            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            if (color === 'blue') {
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
                gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
            }
            if (color === 'white') {
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
            }
            if (color === 'black') {
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
            }
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        function createSpherePoints() {
            const bodyGeometry = new THREE.SphereGeometry(150, 190, 120) //你就一個迴圈，用這個方法生成半徑1~5的同心球  他這個我不知道能不能拼接成一個物件 我用同心球的方法重想一個迴圈好了
            const eyesGeometry = new THREE.Geometry()
            const mouthGeometry = new THREE.Geometry()
            const handGeometry = new THREE.Geometry()
            const footGeometry = new THREE.Geometry()
            const material = new THREE.PointsMaterial({
                size: 3,
                transparent: true,
                map: generateSprite('blue')
            });
            const eyesMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                map: generateSprite('white')
            });
            const mouthMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                map: generateSprite('white')
            });
            const handMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                map: generateSprite('white')
            });
            const footMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                map: generateSprite('white')
            });
            for (let x = -4; x < 4; x++) {
                for (let y = -4; y < 4; y++) {
                    for (let z = -4; z < 4; z++) {
                        if (x * x + y * y + z * z <= 15) {
                            const point = new THREE.Vector3(x * 4, y * 4, z * 4)
                            eyesGeometry.vertices.push(point)
                        }
                    }
                }
            }
            for (let x = -4, y = 0; x < 0;) {
                const topL = new THREE.Vector3(x * 5, y * 5, 0)
                mouthGeometry.vertices.push(topL)
                x++;
                y++;
            }
            for (let x = 0, y = 4; x < 5;) {
                const topR = new THREE.Vector3(x * 5, y * 5, 0)
                mouthGeometry.vertices.push(topR)
                x++;
                y--;
            }
            for (let x = -4; x < 4; x++) {
                const middle = new THREE.Vector3(x * 5, 0, 0)
                mouthGeometry.vertices.push(middle)
            }
            for (let x = -4, y = 0; x < 0;) {
                const bottomL = new THREE.Vector3(x * 5, y * 5, 0)
                mouthGeometry.vertices.push(bottomL)
                x++;
                y--;
            }
            for (let x = 0, y = -4; x < 5;) {
                const bottomR = new THREE.Vector3(x * 5, y * 5, 0)
                mouthGeometry.vertices.push(bottomR)
                x++;
                y++;
            }

            for (let x = -3, y = -5; y < -2;) {
                const left = new THREE.Vector3(x * 5, y * 5, 0)
                footGeometry.vertices.push(left)
                x++;
                y++;
            }
            for (let y = -4; y < 5;) {
                const middle = new THREE.Vector3(0, y * 5, 0)
                footGeometry.vertices.push(middle)
                y++;
            }
            for (let x = 3, y = -5; y < -2;) {
                const right = new THREE.Vector3(x * 5, y * 5, 0)
                footGeometry.vertices.push(right)
                x--;
                y++;
            }// 1 2 3 4 5 4 3 2 1
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    if (x < y) {
                        handGeometry.vertices.push(new THREE.Vector3(x * 5, y * 5, 0))
                    }
                }
            }
            let body = new THREE.Points(bodyGeometry, material),
                leftEyes = new THREE.Points(eyesGeometry, eyesMaterial),
                rightEyes = new THREE.Points(eyesGeometry, eyesMaterial),
                mouth = new THREE.Points(mouthGeometry, mouthMaterial),
                leftHand = new THREE.Points(handGeometry, handMaterial),
                rightHand = new THREE.Points(handGeometry, handMaterial),
                leftFoot = new THREE.Points(footGeometry, footMaterial),
                rightFoot = new THREE.Points(footGeometry, footMaterial);
            body.position.set(0, 0, 0)
            leftEyes.position.set(-50, 55, 120)
            rightEyes.position.set(50, 55, 120)
            mouth.position.set(0, -30, 120)
            leftFoot.position.set(-40, -140, 70)
            rightFoot.position.set(40, -140, 70)
            leftHand.position.set(-130, -30, 70)
            rightHand.position.set(125, 30, 70)
            leftHand.rotation.z+=0.8;
            rightHand.rotation.z+=4;
            scene.add(body, leftEyes, rightEyes, mouth, leftFoot, rightFoot, leftHand,rightHand)
        }

        function init() {
            scene = new THREE.Scene()
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            )
            camera.position.set(0, 0, 400)
            camera.lookAt(scene.position)

            cameraControl = new THREE.OrbitControls(camera)
            // cameraControl.autoRotate = true
            stats = initStats()

            renderer = new THREE.WebGLRenderer()
            renderer.setSize(window.innerWidth, window.innerHeight)

            // 創建粒子系統
            createSpherePoints()

            // spotlight
            let spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-10, 40, 30)
            scene.add(spotLight)

            document.body.appendChild(renderer.domElement)
        }

        function render() {
            stats.update()
            requestAnimationFrame(render)
            cameraControl.update()
            renderer.render(scene, camera)
        }

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })

        init()
        render()

    </script>
</body>

=======
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    body {
        margin: 0px;
    }

    #stats {
        position: absolute;
        left: 0;
        top: 0;
    }
</style>

<body>
    <div id="stats"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/96/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

    <script>
        let renderer, scene, camera;
        let cameraControl, stats;

        function initStats() {
            const stats = new Stats();
            stats.setMode(0);
            document.getElementById('stats').appendChild(stats.domElement);
            return stats;
        }

        // 自訂頂點創建粒子系統

        function generateSprite() {
            var canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;

            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        function createSpherePoints() {
            const geometry = new THREE.SphereGeometry(60, 60, 20)
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                transparent: true,
                blending: THREE.AdditiveBlending,
                map: generateSprite()
            });
            let spherePoints = new THREE.Points(geometry, material) // 用球體與材質建立一個粒子系統
            spherePoints.position.set(0, 0, 0)
            scene.add(spherePoints)
        }

        function init() {
            scene = new THREE.Scene()
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            )
            camera.position.set(0, 0, 100)
            camera.lookAt(scene.position)

            cameraControl = new THREE.OrbitControls(camera)
            cameraControl.autoRotate = true
            stats = initStats()

            renderer = new THREE.WebGLRenderer()
            renderer.setSize(window.innerWidth, window.innerHeight)

            // 創建粒子系統
            createSpherePoints()

            // spotlight
            let spotLight = new THREE.SpotLight(0xffffff)
            spotLight.position.set(-10, 40, 30)
            scene.add(spotLight)

            document.body.appendChild(renderer.domElement)
        }

        function render() {
            stats.update()
            requestAnimationFrame(render)
            cameraControl.update()
            renderer.render(scene, camera)
        }

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
        })

        init()
        render()

    </script>
</body>

>>>>>>> 7c4a97f71fe720adb59bf3ca93fbb7914f822df9
</html>